# 히어로 섹션: 개발환경 vs 배포 후 로딩 차이 원인 분석

## 현상 정리

| 환경 | 동작 |
|------|------|
| **개발환경** | 그라데이션과 배경 이미지가 **동시에** 나타남 |
| **배포 후** | 그라데이션만 먼저 뜨고, **한참 뒤에** 이미지가 로딩됨 |

---

## 원인 분석

### 1. **이미지 요청 시점 (Discovery)**

- 히어로 이미지는 **인라인 스타일**로 지정되어 있음:
  ```html
  <section class="heroSection" style="background-image: linear-gradient(...), url('assets/images/...');">
  ```
- `url(...)` 은 **섹션이 DOM에 그려질 때** 비로소 브라우저에 알려짐.
- `<link rel="preload" as="image" href="...">` 가 head에 있어도, **preload는 favicon·stylesheet 뒤**에 있어서, 실제 이미지 요청이 상대적으로 늦게 시작될 수 있음.
- **개발**: 로컬(localhost/파일)이라 요청이 조금 늦어도 응답이 거의 즉시 옴 → 그라데이션과 이미지가 동시에 보이는 것처럼 느껴짐.
- **배포**: 같은 시점에 요청해도 **원격 서버(CDN) 응답 + 다운로드 시간**이 추가됨 → 그라데이션만 먼저 보이고, 이미지는 나중에 나타남.

→ **요청은 비슷한 시점이지만, “응답이 오는 속도”가 환경마다 크게 다름.**

---

### 2. **네트워크 지연 + 파일 크기**

| 구분 | 개발환경 | 배포 후 |
|------|----------|---------|
| **이미지 위치** | 로컬 디스크 / localhost | CDN·원격 서버 |
| **지연 (RTT)** | 거의 없음 | 수십~수백 ms |
| **다운로드** | 로컬 I/O로 매우 빠름 | 네트워크 대역폭에 의존 |
| **캐시** | 같은 페이지 여러 번 보면 로컬 캐시 | 첫 방문 시 캐시 없음 |

- 히어로 이미지가 **수백 KB ~ 1MB** 정도면:
  - **개발**: 수 ms ~ 수십 ms 안에 로딩 → 그라데이션과 거의 동시.
  - **배포**: 0.5~2초 이상 걸리기 쉬움 → 그라데이션만 먼저 보이다가, 이미지가 늦게 뜸.

→ **같은 코드라도 “이미지를 받는 데 걸리는 시간”이 배포 환경에서 훨씬 길어짐.**

---

### 3. **그라데이션은 왜 항상 먼저 보이는가**

- `background-image: linear-gradient(...), url('...');` 에서:
  - **linear-gradient(...)** 는 **순수 CSS 계산**이라 네트워크 요청 없이 바로 그려짐.
  - **url('...')** 는 **별도 이미지 리소스**라 다운로드·디코딩이 끝나야 그려짐.
- 그래서:
  - **항상** 그라데이션은 즉시 표시되고,
  - 이미지는 **다운로드 + 디코딩이 끝난 뒤**에야 위에 겹쳐서 보임.
- 개발에서는 이미지 다운로드가 너무 빨라서 “동시에 뜬다”고 느끼는 것이고,
- 배포에서는 이 “다운로드 + 디코딩” 시간이 길어져서 “그라데이션만 있다가 한참 뒤에 이미지”로 보이는 것.

→ **원인: 이미지 수신·디코딩이 끝나기 전까지는 그라데이션만 그려지기 때문.**

---

### 4. **Preload만으로 부족한 이유**

- 현재 preload는 **favicon 다음, stylesheet 전**에 있음.
- 브라우저는 **HTML 파싱 순서**와 **리소스 우선순위**에 따라 요청을 스케줄링함.
- Preload가 있어도:
  - **배포 환경**에서는 **첫 바이트까지의 지연(RTT)** 와 **이미지 크기** 때문에, “요청은 빨리 보냈지만 받는 데 시간이 걸림” → 여전히 그라데이션만 먼저 보이다가 이미지가 늦게 뜸.
- 즉, **요청 시점을 앞당기는 것**만으로는, **다운로드 시간**을 줄일 수 없음.

→ **Preload는 “언제 요청하느냐”만 개선하고, “배포 서버에서 얼마나 빨리 받느냐”는 네트워크·파일 크기에 달려 있음.**

---

## 요약: 왜 개발에서는 동시에, 배포에서는 한참 뒤에 뜨는가

1. **그라데이션**  
   - CSS만으로 계산되므로 **항상 즉시** 그려짐. (개발/배포 동일)

2. **이미지**  
   - **개발**: 로컬에서 읽어와서 **거의 동시에** 로딩 → 그라데이션과 함께 보임.  
   - **배포**: 원격에서 받아와야 해서 **지연 + 다운로드 시간**이 생김 → 그라데이션만 먼저 보이고, 이미지는 “한참 있다가” 뜸.

3. **정리**  
   - **원인**: 배포 환경에서 히어로 이미지의 **네트워크 지연 + 다운로드/디코딩 시간**이 커서, 그라데이션(즉시 렌더)과 이미지(나중에 렌더) 사이에 시간 차가 생기는 것.
   - **개발에서 동시에 보이는 이유**: 같은 코드여도 로컬에서는 이미지가 너무 빨리 와서, 체감상 “동시에” 뜨는 것.

---

## 개선 시 고려할 수 있는 방향 (참고)

- **이미지 용량 줄이기**:  
  `npm run optimize:hero` 등으로 히어로 이미지 리사이즈·압축 → 배포에서도 다운로드 시간 단축.
- **WebP 제공**:  
  같은 화질에서 용량이 더 작아져, 배포에서 더 빨리 받을 수 있음.
- **LQIP (저해상도 placeholder)**:  
  아주 작은 블러 이미지나 단색을 먼저 보여 주고, 본 이미지 로드 후 전환 → “한참 있다가 뜬다”는 체감을 줄일 수 있음.
- **Preload 위치**:  
  head 최상단(viewport 직후)에 두면 요청을 더 일찍 보낼 수 있음. (이전에 버벅임 이슈로 되돌렸던 변경이므로, 재적용 시 성능 영향만 확인 필요.)

이 문서는 원인 분석용이며, 실제 수정은 필요 시 별도로 진행하면 됩니다.
